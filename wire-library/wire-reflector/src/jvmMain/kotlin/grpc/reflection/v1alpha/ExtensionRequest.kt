// Code generated by Wire protocol buffer compiler, do not edit.
// Source: grpc.reflection.v1alpha.ExtensionRequest in grpc/reflection/v1alpha/reflection.proto
package grpc.reflection.v1alpha

import com.squareup.wire.FieldEncoding
import com.squareup.wire.Message
import com.squareup.wire.ProtoAdapter
import com.squareup.wire.ProtoReader
import com.squareup.wire.ProtoWriter
import com.squareup.wire.Syntax.PROTO_3
import com.squareup.wire.WireField
import com.squareup.wire.`internal`.sanitize
import kotlin.Any
import kotlin.Boolean
import kotlin.Int
import kotlin.Long
import kotlin.String
import kotlin.Unit
import kotlin.hashCode
import kotlin.jvm.JvmField
import okio.ByteString

/**
 * The type name and extension number sent by the client when requesting
 * file_containing_extension.
 */
public class ExtensionRequest(
  /**
   * Fully-qualified type name. The format should be <package>.<type>
   */
  @field:WireField(
    tag = 1,
    adapter = "com.squareup.wire.ProtoAdapter#STRING",
    label = WireField.Label.OMIT_IDENTITY,
    jsonName = "containingType"
  )
  @JvmField
  public val containing_type: String = "",
  @field:WireField(
    tag = 2,
    adapter = "com.squareup.wire.ProtoAdapter#INT32",
    label = WireField.Label.OMIT_IDENTITY,
    jsonName = "extensionNumber"
  )
  @JvmField
  public val extension_number: Int = 0,
  unknownFields: ByteString = ByteString.EMPTY
) : Message<ExtensionRequest, ExtensionRequest.Builder>(ADAPTER, unknownFields) {
  public override fun newBuilder(): Builder {
    val builder = Builder()
    builder.containing_type = containing_type
    builder.extension_number = extension_number
    builder.addUnknownFields(unknownFields)
    return builder
  }

  public override fun equals(other: Any?): Boolean {
    if (other === this) return true
    if (other !is ExtensionRequest) return false
    if (unknownFields != other.unknownFields) return false
    if (containing_type != other.containing_type) return false
    if (extension_number != other.extension_number) return false
    return true
  }

  public override fun hashCode(): Int {
    var result = super.hashCode
    if (result == 0) {
      result = unknownFields.hashCode()
      result = result * 37 + containing_type.hashCode()
      result = result * 37 + extension_number.hashCode()
      super.hashCode = result
    }
    return result
  }

  public override fun toString(): String {
    val result = mutableListOf<String>()
    result += """containing_type=${sanitize(containing_type)}"""
    result += """extension_number=$extension_number"""
    return result.joinToString(prefix = "ExtensionRequest{", separator = ", ", postfix = "}")
  }

  public fun copy(
    containing_type: String = this.containing_type,
    extension_number: Int = this.extension_number,
    unknownFields: ByteString = this.unknownFields
  ): ExtensionRequest = ExtensionRequest(containing_type, extension_number, unknownFields)

  public class Builder : Message.Builder<ExtensionRequest, Builder>() {
    @JvmField
    public var containing_type: String = ""

    @JvmField
    public var extension_number: Int = 0

    /**
     * Fully-qualified type name. The format should be <package>.<type>
     */
    public fun containing_type(containing_type: String): Builder {
      this.containing_type = containing_type
      return this
    }

    public fun extension_number(extension_number: Int): Builder {
      this.extension_number = extension_number
      return this
    }

    public override fun build(): ExtensionRequest = ExtensionRequest(
      containing_type = containing_type,
      extension_number = extension_number,
      unknownFields = buildUnknownFields()
    )
  }

  public companion object {
    @JvmField
    public val ADAPTER: ProtoAdapter<ExtensionRequest> = object : ProtoAdapter<ExtensionRequest>(
      FieldEncoding.LENGTH_DELIMITED, 
      ExtensionRequest::class, 
      "type.googleapis.com/grpc.reflection.v1alpha.ExtensionRequest", 
      PROTO_3, 
      null
    ) {
      public override fun encodedSize(value: ExtensionRequest): Int {
        var size = value.unknownFields.size
        if (value.containing_type != "") size += ProtoAdapter.STRING.encodedSizeWithTag(1,
            value.containing_type)
        if (value.extension_number != 0) size += ProtoAdapter.INT32.encodedSizeWithTag(2,
            value.extension_number)
        return size
      }

      public override fun encode(writer: ProtoWriter, value: ExtensionRequest): Unit {
        if (value.containing_type != "") ProtoAdapter.STRING.encodeWithTag(writer, 1,
            value.containing_type)
        if (value.extension_number != 0) ProtoAdapter.INT32.encodeWithTag(writer, 2,
            value.extension_number)
        writer.writeBytes(value.unknownFields)
      }

      public override fun decode(reader: ProtoReader): ExtensionRequest {
        var containing_type: String = ""
        var extension_number: Int = 0
        val unknownFields = reader.forEachTag { tag ->
          when (tag) {
            1 -> containing_type = ProtoAdapter.STRING.decode(reader)
            2 -> extension_number = ProtoAdapter.INT32.decode(reader)
            else -> reader.readUnknownField(tag)
          }
        }
        return ExtensionRequest(
          containing_type = containing_type,
          extension_number = extension_number,
          unknownFields = unknownFields
        )
      }

      public override fun redact(value: ExtensionRequest): ExtensionRequest = value.copy(
        unknownFields = ByteString.EMPTY
      )
    }

    private const val serialVersionUID: Long = 0L
  }
}
